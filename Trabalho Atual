#include <stdio.h>
#include <stdlib.h>
#define TAMANHO_MATRIZ 8
#define MAX 36 // Tamanho máximo da pilha

char Pilha[MAX]; // Pilha
int top = -1; // Topo da pilha
int PRIMEIRA_PECA=1;

void inicializarMatriz(char ***matriz) {
    *matriz = (char **)malloc(TAMANHO_MATRIZ * sizeof(char *));
    for (int i = 0; i < TAMANHO_MATRIZ; i++) {
        (*matriz)[i] = (char *)malloc(TAMANHO_MATRIZ * sizeof(char));
        for (int j = 0; j < TAMANHO_MATRIZ; j++) {
            (*matriz)[i][j] = ' ';
        }
    }
}

// Função para imprimir a pilha
void printPilha() {
    int i;
    for (i = 0; i <= top; i++) {
        printf("%c ", Pilha[i]);
    }
    printf("\n");
}

// Função para adicionar um elemento à pilha
void PilhaPronta(char c) {
    if (top >= MAX - 1) {
        printf("Pilha cheia\n");
    } else {
        Pilha[++top] = c;
    }
}

// Função para embaralhar um array
void Randomizar(char *array, int n) {
    if (n > 1) {
        int i;
        for (i = 0; i < n - 1; i++) {
          int j = i + rand() / (RAND_MAX / (n - i) + 1);
          char t = array[j];
          array[j] = array[i];
          array[i] = t;
        }
    }
}

void imprimirMatriz(char **matriz) {
    system("cls");
    printf("      1    2    3    4    5    6\n");

    for (int i = 1; i < TAMANHO_MATRIZ-1; i++) {
        if (i<9)
        printf("%d   ", i);
        for (int j = 1; j < TAMANHO_MATRIZ-1; j++) {
            printf("[%2c ]", matriz[i][j]);
        }
        printf("\n\n");
    }
}

// Tira uma peça do topo da pilha
char Tirar() {
    if (top < 0) {
        printf("Pilha vazia\n");
        return '\0';
    } else {
        return Pilha[top--];
    }
}

int matrizCheia(char **matriz) {
    for (int i = 1; i < TAMANHO_MATRIZ-1; i++) {
        for (int j = 1; j < TAMANHO_MATRIZ-1; j++) {
            if (matriz[i][j] == ' ') {
                return 0; // A matriz ainda não está cheia
            }
        }
    }
    return 1; // A matriz está cheia
}

int pode(char **matriz, int x, int y ) {
    if (PRIMEIRA_PECA==1){
        PRIMEIRA_PECA=0;
        return 1;}// Primeira Peça
    if (x > 0 && matriz[x - 1][y] != ' ')
        return 1; // Acima
    if (x < TAMANHO_MATRIZ - 1 && matriz[x + 1][y] != ' ')
        return 1; // Abaixo
    if (y > 0 && matriz[x][y - 1] != ' ')
        return 1; // À esquerda
    if (y < TAMANHO_MATRIZ - 1 && matriz[x][y + 1] != ' ')
        return 1; // À direita
    return 0; // Nenhuma posição adjacente preenchida
}
int main() {
    char letters[MAX];
    int i, j;
    char **matriz;
    srand(time(NULL));
    // Adiciona 6 de cada letra ao array
    for (i = 0; i < 6; i++) {
        for (j = 0; j < 6; j++) {
            letters[i*6 + j] = 'A' + i;
        }
    }
    srand(time(NULL));
    Randomizar(letters, MAX);
    for (i = 0; i < MAX; i++) {
        PilhaPronta(letters[i]);
    }
    inicializarMatriz(&matriz);

    imprimirMatriz(matriz);

    while (!matrizCheia(matriz)) {
        int x, y;
        printf("Escolha uma posição adjacente (linha e coluna) para colocar a próxima peça 'B' (1 a 6): ");
        scanf("%d %d", &x, &y);

        if (x >= 1 && x <= 7 && y >= 1 && y <= 7 && matriz[x][y] == ' ' && pode(matriz, x, y)==1) {
            matriz[x][y] = Tirar();
            printf("Peça 'B' colocada com sucesso.\n");
            imprimirMatriz(matriz);
            printPilha();
        }
        else {
            printf("Posição inválida. Tente novamente.\n");
        }
    }
}
