#include <stdio.h>
#include <stdlib.h>
#define TAMANHO_MATRIZ 8
#define MAX 36 // Tamanho máximo da pilha

char Pilha[MAX]; // Pilha
int top = -1; // Topo da pilha
int PRIMEIRA_PECA=1;

void inicializarMatriz(char ***matriz) {
    *matriz = (char **)malloc(TAMANHO_MATRIZ * sizeof(char *));
    for (int i = 0; i < TAMANHO_MATRIZ; i++) {
        (*matriz)[i] = (char *)malloc(TAMANHO_MATRIZ * sizeof(char));
        for (int j = 0; j < TAMANHO_MATRIZ; j++) {
            (*matriz)[i][j] = ' ';
        }
    }
}

// Função para embaralhar
void Randomizar(char *numero, int n) {
    srand(time(NULL));
    if (n > 1) {
        int i;
        for (i = 0; i < n - 1; i++) {
          int j = i + rand() / (RAND_MAX / (n - i) + 1);
          char t = numero[j];
          numero[j] = numero[i];
          numero[i] = t;
        }
    }
}

void imprimirMatriz(char **matriz) {
    system("cls");
    printf("      1    2    3    4    5    6\n");

    for (int i = 1; i < TAMANHO_MATRIZ-1; i++) {
        if (i<9)
        printf("%d   ", i);
        for (int j = 1; j < TAMANHO_MATRIZ-1; j++) {
            printf("[%2c ]", matriz[i][j]);
        }
        printf("\n\n");
    }
}

// Tira uma peça do topo da pilha
char Tirar (char *letters, int *proxima) {
    if (*proxima == -1) {
        printf("A pilha está vazia.\n");
        return '\0'; // retorna nulo se a pilha estiver vazia
    } else {
        (*proxima)--; // decrementa o topo da pilha
        return letters[*proxima]; // retorna o elemento do topo da pilha
    }
}

int matrizCheia(char **matriz) {
    for (int i = 1; i < TAMANHO_MATRIZ-1; i++) {
        for (int j = 1; j < TAMANHO_MATRIZ-1; j++) {
            if (matriz[i][j] == ' ') {
                return 0; // A matriz ainda não está cheia
            }
        }
    }
    return 1; // A matriz está cheia
}

void PreencherPilha(char *letters) {
    for (int i = MAX-1; i >= 0; i--) {
        Pilha[MAX-1-i] = letters[i];
    }
    top = MAX - 1;
}

int pode(char **matriz, int x, int y ) {
    if (PRIMEIRA_PECA==1){
        PRIMEIRA_PECA=0;
        return 1;}// Primeira Peça
    if (x > 0 && matriz[x - 1][y] != ' ')
        return 1; // Acima
    if (x < TAMANHO_MATRIZ - 1 && matriz[x + 1][y] != ' ')
        return 1; // Abaixo
    if (y > 0 && matriz[x][y - 1] != ' ')
        return 1; // À esquerda
    if (y < TAMANHO_MATRIZ - 1 && matriz[x][y + 1] != ' ')
        return 1; // À direita
    return 0; // Nenhuma posição adjacente preenchida
}

int main() {
    char letters[MAX];
    int i, j;
    char **matriz;
    // Adiciona 6 de cada letra ao array
    for (i = 0; i < 6; i++) {
        for (j = 0; j < 6; j++) {
            letters[j*6 + i] = 'A' + i;
        }
    }
    Randomizar(letters, MAX);
    PreencherPilha(letters);
    inicializarMatriz(&matriz);
    imprimirMatriz(matriz);

    while (!matrizCheia(matriz)) {
        int x=0, y=0;
        printf("Escolha uma posicao adjacente (linha e coluna) para colocar a proxima peça 'B' (1 a 6):\n ");
        printf("A proxima peca eh: %c\n", letters[top-1]);

    while (x < 1 || x > 6 && y < 1 || y > 6)
        scanf("%d %d", &x, &y);

        if (x >= 1 && x <= 7 && y >= 1 && y <= 7 && matriz[x][y] == ' ' && pode(matriz, x, y)==1) {
            matriz[x][y] = Tirar(letters, &top);
            printf("Peça 'B' colocada com sucesso.\n");
            imprimirMatriz(matriz);
        }
        else {
            imprimirMatriz(matriz);
            printf("Posicao invalida. Tente novamente.\n");

        }
    }
}
